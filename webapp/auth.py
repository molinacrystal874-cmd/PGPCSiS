import random
from flask import Blueprint, render_template, request, redirect, url_for, flash, session, jsonify, make_response
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import login_user, login_required, current_user, logout_user
from .models import User, Student, db

# Define the Blueprint
auth = Blueprint('auth', __name__)

@auth.route('/', methods=['GET', 'POST'])
@auth.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        login_id = request.form.get('loginId') 
        password = request.form.get('password')
        role = request.form.get('role') 

        # -----------------------------------------
        # üîê NEW SECURITY CHECK: Validate role field
        # -----------------------------------------
        if role not in ('staff', 'student'):
            flash('Invalid role selected.', 'error')
            return redirect(url_for('auth.login'))

        if role == 'staff':
            user = User.query.filter_by(email=login_id).first()
        else:
            user = Student.query.filter_by(student_id=login_id).first()
            
            if not user:
                import csv
                import os
                from flask import current_app
                
                csv_path = os.path.join(current_app.root_path, 'data', 'students_data.csv')
                try:
                    with open(csv_path, 'r', encoding='utf-8') as file:
                        reader = csv.DictReader(file)
                        for row in reader:
                            if row['student_id'].strip() == login_id.strip():
                                if password == row['student_id'].strip():
                                    user = Student(
                                        full_name=row['full_name'],
                                        email=row['email'],
                                        password_hash=generate_password_hash(password, method='pbkdf2:sha256'),
                                        student_id=row['student_id'],
                                        program=row['program'],
                                        section=row['section'],
                                        password_changed=False
                                    )
                                    db.session.add(user)
                                    db.session.commit()
                                break
                except FileNotFoundError:
                    pass

        if user and check_password_hash(user.password_hash, password):
            # üîê NEW: Regenerate session to prevent session fixation
            session.clear()

            login_user(user) 
            session['user_id'] = str(user.id) 
            
            if role == 'staff':
             session['user_name'] = getattr(user, 'name', user.email)
             session['user_role'] = 'staff'     # <-- REQUIRED, FIXED VALUE
             session['user_section'] = None  
 
            else:
             session['user_name'] = user.full_name
             session['user_role'] = 'student'
             session['user_section'] = user.section
 

            flash(f'Logged in successfully as {session["user_name"]}!', 'success')
            
            # --- FORCED PASSWORD CHANGE LOGIC FOR STUDENTS ---
            if role == 'student':
                if not user.password_changed:
                    session.pop('otp_code', None)
                    session.pop('otp_sent', None)
                    session.pop('otp_verified', None)
                    
                    flash('Please update your default password for security.', 'warning')
                    return redirect(url_for('auth.change_password'))
                
                return redirect(url_for('views.student_home'))
            
            else:
                return redirect(url_for('views.admin_home'))
        else:
            flash('Login failed: Check your ID/Email and password.', 'error')

    return render_template('login.html', sis_title="PGPC SIS Portal")


# --------------------------------------------------------------------
# >>> NEW: ROUTE TO STORE OTP GENERATED BY CLIENT-SIDE JAVASCRIPT
# --------------------------------------------------------------------
@auth.route('/store-otp', methods=['POST'])
@login_required 
def store_otp():
    """Stores the OTP code generated client-side into the Flask session."""
    if request.is_json:
        data = request.get_json()
        otp_code = data.get('otp_code')
        
        if otp_code:
            # Store the code in the session for later verification
            session['otp_code'] = otp_code
            session['otp_sent'] = True # Mark it as sent after successful client generation/storage
            return jsonify({'status': 'success'}), 200
        
        return jsonify({'status': 'failure', 'message': 'No OTP code provided'}), 400
    
    return jsonify({'status': 'failure', 'message': 'Request must be JSON'}), 400


# --------------------------------------------------------------------
# >>> MODIFIED PASSWORD CHANGE ROUTE FOR MANUAL OTP SEND
# --------------------------------------------------------------------
@auth.route('/change-password', methods=['GET', 'POST'])
@login_required 
def change_password():
    """Handles the forced password change process using client-side EmailJS for OTP sending."""
    
    # 1. LOOP PREVENTION & Security Checks
    if session.get('user_role') != 'student' or current_user.password_changed:
        if current_user.password_changed:
            return redirect(url_for('views.student_home'))
        flash('Access denied.', 'error')
        return redirect(url_for('auth.login')) 
    
    # Initialize state from session
    otp_sent = session.get('otp_sent', False)
    otp_verified = session.get('otp_verified', False)
    
    # --- HANDLE POST REQUEST (Form Submissions) ---
    if request.method == 'POST':
        action = request.form.get('action')
        
        # --- ACTION: Verify OTP (Handled by backend using stored OTP) ---
        if action == 'verify_otp':
            input_otp = request.form.get('input_otp', '').strip() # Strip whitespace from user input
            stored_otp = session.get('otp_code', None)
            
            if stored_otp and str(input_otp) == str(stored_otp): 
                session['otp_verified'] = True
                flash('Code verified. You can now set your new password.', 'success')
            else:
                flash('Invalid verification code. Please try again.', 'error')
                
            return redirect(url_for('auth.change_password'))

        # --- ACTION: Set New Password ---
        elif action == 'set_password' and otp_verified:
            new_password = request.form.get('new_password')
            confirm_password = request.form.get('confirm_password')

            if new_password != confirm_password:
                flash('New password and confirmation do not match.', 'error')
            elif len(new_password) < 6:
                flash('Password must be at least 6 characters long.', 'error')
            else:
                try:
                    current_user.password_hash = generate_password_hash(new_password, method='pbkdf2:sha256')
                    current_user.password_changed = True
                    db.session.commit()
                    
                    # Clean up session and force re-login
                    session.clear() 
                    flash('Password successfully updated! Please log in with your new password.', 'success')
                    return redirect(url_for('auth.login')) 
                
                except Exception as e:
                    db.session.rollback()
                    flash(f'An error occurred while updating the password: {e}', 'error')

        return redirect(url_for('auth.change_password'))

    # --- HANDLE GET REQUEST (Render Template) ---
    # We no longer generate the OTP here. We only render the current state.
    
    # Fix: Explicitly pass generated_otp as None to prevent Jinja2's Undefined type 
    # from causing the JSON serialization error.
    return render_template('change_password.html', 
                           otp_sent=otp_sent, # Passed so JS can check if the form should be hidden
                           otp_verified=otp_verified,
                           user_email=current_user.email,
                           user_name=current_user.full_name,
                           generated_otp=None) # <<< FIX APPLIED HERE

@auth.route('/signup', methods=['GET', 'POST'])
def signup():
# ... (Your existing signup code remains here, unchanged)
    if request.method == 'POST':
        # Collect all registration fields
        name = request.form.get('regName')
        student_id = request.form.get('regStudentId')
        email = request.form.get('regEmail')
        program = request.form.get('regProgram')
        section = request.form.get('regSection')
        password = request.form.get('regPass')

        # Check for existing account
        if Student.query.filter_by(email=email).first() or Student.query.filter_by(student_id=student_id).first():
            flash('An account with this email or student ID already exists.', 'error')
            return redirect(url_for('auth.signup'))

        hashed_password = generate_password_hash(password, method='pbkdf2:sha256')

        new_student = Student(
            full_name=name,
            email=email,
            password_hash=hashed_password,
            student_id=student_id,
            program=program,
            section=section,
            password_changed=True 
        )

        try:
            db.session.add(new_student)
            db.session.commit()
            flash('Account created successfully! You can now log in.', 'success')
            return redirect(url_for('auth.login'))
        except Exception as e:
            db.session.rollback()
            flash(f'Error creating account: {e}', 'error')
            return redirect(url_for('auth.signup'))

    return render_template('signup.html', sis_title="PGPS SIS Portal")


@auth.route('/test-route', methods=['GET'])
def test_route():
    return jsonify({"message": "Auth routes are working", "available_routes": ["forgot-password", "reset-password"]})

@auth.route('/debug-csv', methods=['GET'])
def debug_csv():
    """Debug route to check CSV file access"""
    import csv
    import os
    from flask import current_app
    
    possible_paths = [
        os.path.join(os.path.dirname(__file__), 'data', 'students_data.csv'),
        os.path.join(current_app.root_path, 'data', 'students_data.csv'),
        os.path.join(os.getcwd(), 'webapp', 'data', 'students_data.csv')
    ]
    
    result = {"paths_tried": [], "emails_found": []}
    
    for csv_path in possible_paths:
        try:
            result["paths_tried"].append({"path": csv_path, "exists": os.path.exists(csv_path)})
            if os.path.exists(csv_path):
                with open(csv_path, 'r', encoding='utf-8') as file:
                    reader = csv.DictReader(file)
                    for row in reader:
                        result["emails_found"].append(row['email'].strip().lower())
                break
        except Exception as e:
            result["paths_tried"].append({"path": csv_path, "error": str(e)})
    
    return jsonify(result)

@auth.route('/forgot-password', methods=['POST'])
def forgot_password():
    """Handle forgot password requests for both staff and students."""
    print("=== FORGOT PASSWORD ROUTE CALLED ===")
    try:
        data = request.get_json()
        print(f"Request data: {data}")
        email = data.get('email', '').strip().lower()
        user_type = data.get('user_type', 'student')  # Default to student
        print(f"Processing email: '{email}', user_type: '{user_type}'")
        
        if not email:
            return jsonify({'success': False, 'message': 'Email is required'}), 400
        
        user = None
        user_name = None
        
        # Check staff database first
        user = User.query.filter_by(email=email).first()
        if user:
            user_name = user.name
            user_type = 'staff'  # Override user_type
            print(f"Found staff user: {user_name}")
        else:
            # Check student database
            user = Student.query.filter_by(email=email).first()
            if user:
                user_name = user.full_name
                user_type = 'student'  # Override user_type
                print(f"Found database student: {user_name}")
            else:
                # Check CSV file for students
                import csv
                import os
                from flask import current_app
                
                csv_path = os.path.join(current_app.root_path, 'data', 'students_data.csv')
                print(f"Looking for CSV at: {csv_path}")
                print(f"File exists: {os.path.exists(csv_path)}")
                
                try:
                    with open(csv_path, 'r', encoding='utf-8') as file:
                        reader = csv.DictReader(file)
                        for row in reader:
                            row_email = row['email'].strip().lower()
                            print(f"Comparing: '{row_email}' == '{email}' = {row_email == email}")
                            if row_email == email:
                                user_name = row['full_name']
                                user_type = 'student'  # Override user_type
                                user = type('CSVUser', (), {
                                    'email': email,
                                    'full_name': user_name,
                                    'student_id': row['student_id'],
                                    'is_csv_user': True
                                })()
                                print(f"Found CSV user: {user_name}")
                                break
                except Exception as e:
                    print(f"Error reading CSV: {e}")
        
        if not user:
            return jsonify({'success': False, 'message': 'Email not found in our records'}), 404
        
        # Generate OTP and store in session
        import random
        otp_code = str(random.randint(100000, 999999))
        session[f'reset_otp_{email}'] = otp_code
        session[f'reset_email_{email}'] = email
        session[f'reset_user_type_{email}'] = user_type
        print(f"Storing user_type as: {user_type}")
        
        return jsonify({
            'success': True, 
            'message': f'Verification code ready for {email}',
            'otp_code': otp_code,
            'user_name': user_name
        }), 200
        
    except Exception as e:
        print(f"Forgot password error: {e}")
        return jsonify({'success': False, 'message': 'An error occurred'}), 500

@auth.route('/reset-password', methods=['POST'])
def reset_password():
    """Reset password after OTP verification."""
    try:
        data = request.get_json()
        email = data.get('email', '').strip().lower()
        otp_code = data.get('otp_code', '').strip()
        new_password = data.get('new_password', '').strip()
        
        if not all([email, otp_code, new_password]):
            return jsonify({'success': False, 'message': 'All fields are required'}), 400
        
        if len(new_password) < 6:
            return jsonify({'success': False, 'message': 'Password must be at least 6 characters'}), 400
        
        # Verify OTP
        stored_otp = session.get(f'reset_otp_{email}')
        if not stored_otp or str(stored_otp) != str(otp_code):
            return jsonify({'success': False, 'message': 'Invalid verification code'}), 400
        
        user_type = session.get(f'reset_user_type_{email}', 'student')
        
        if user_type == 'staff':
            # Update staff user in database
            user = User.query.filter_by(email=email).first()
            if user:
                user.password_hash = generate_password_hash(new_password, method='pbkdf2:sha256')
                db.session.commit()
            else:
                return jsonify({'success': False, 'message': 'User not found'}), 404
        else:
            # Update student in database
            user = Student.query.filter_by(email=email).first()
            if user:
                user.password_hash = generate_password_hash(new_password, method='pbkdf2:sha256')
                user.password_changed = True
                db.session.commit()
            else:
                # Handle CSV student - create database entry
                import csv
                import os
                from flask import current_app
                
                csv_path = os.path.join(current_app.root_path, 'data', 'students_data.csv')
                student_found = False
                try:
                    with open(csv_path, 'r', encoding='utf-8') as file:
                        reader = csv.DictReader(file)
                        for row in reader:
                            if row['email'].strip().lower() == email:
                                new_student = Student(
                                    full_name=row['full_name'],
                                    email=email,
                                    password_hash=generate_password_hash(new_password, method='pbkdf2:sha256'),
                                    student_id=row['student_id'],
                                    program=row['program'],
                                    section=row['section'],
                                    password_changed=True
                                )
                                db.session.add(new_student)
                                db.session.commit()
                                student_found = True
                                break
                except Exception as e:
                    print(f"Error reading CSV for reset: {e}")
                
                if not student_found:
                    return jsonify({'success': False, 'message': 'Student not found'}), 404
        
        # Clear session data
        session.pop(f'reset_otp_{email}', None)
        session.pop(f'reset_email_{email}', None)
        session.pop(f'reset_user_type_{email}', None)
        
        return jsonify({'success': True, 'message': 'Password updated successfully'}), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"Reset password error: {e}")
        return jsonify({'success': False, 'message': 'An error occurred while updating password'}), 500

@auth.route('/logout')
def logout():
    logout_user()          # clear flask-login
    session.clear()        # remove user_id, user_role, etc.
    flash('You have been logged out.', 'info')
    
    # üåü FIX APPLIED HERE: Use make_response to create a fresh response object 
    # and force the 302 redirect, effectively breaking the browser history loop.
    response = make_response(redirect(url_for('auth.login')))
    return response # <<< MODIFIED RETURN VALUE